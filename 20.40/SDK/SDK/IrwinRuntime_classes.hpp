#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: IrwinRuntime

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "IrwinRuntime_structs.hpp"
#include "FortniteGame_classes.hpp"


namespace SDK
{

// Class IrwinRuntime.FortAIFaunaAnimInstance
// 0x0050 (0x0580 - 0x0530)
class UFortAIFaunaAnimInstance : public UFortAIAnimInstance
{
public:
	float                                         AverageSpeed;                                      // 0x0528(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AverageSpeedTimeFrame;                             // 0x052C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasValidAimTarget;                                // 0x0530(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_531[0x7];                                      // 0x0531(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AimTargetLocation;                                 // 0x0538(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSurfaceSwimming;                                // 0x0550(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovingOnGround;                                 // 0x0551(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInTornado;                                      // 0x0552(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_553[0x1];                                      // 0x0553(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtAlpha;                                       // 0x0554(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceToPlayerForLookAt;                      // 0x0558(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtTooFarFromPlayerTimeOut;                     // 0x055C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableLookAtDuringMontage;                       // 0x0560(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_561[0x3];                                      // 0x0561(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DisableHeadTrackingCurveName;                      // 0x0564(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRidingAnimationData                   RidingAnimationData;                               // 0x0568(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_574[0xC];                                      // 0x0574(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalculateLookAtAlpha(bool bForceDisableLookAt, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance">();
	}
	static class UFortAIFaunaAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance");
static_assert(sizeof(UFortAIFaunaAnimInstance) == 0x000580, "Wrong size on UFortAIFaunaAnimInstance");
static_assert(offsetof(UFortAIFaunaAnimInstance, AverageSpeed) == 0x000528, "Member 'UFortAIFaunaAnimInstance::AverageSpeed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, AverageSpeedTimeFrame) == 0x00052C, "Member 'UFortAIFaunaAnimInstance::AverageSpeedTimeFrame' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bHasValidAimTarget) == 0x000530, "Member 'UFortAIFaunaAnimInstance::bHasValidAimTarget' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, AimTargetLocation) == 0x000538, "Member 'UFortAIFaunaAnimInstance::AimTargetLocation' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsSurfaceSwimming) == 0x000550, "Member 'UFortAIFaunaAnimInstance::bIsSurfaceSwimming' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsMovingOnGround) == 0x000551, "Member 'UFortAIFaunaAnimInstance::bIsMovingOnGround' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsInTornado) == 0x000552, "Member 'UFortAIFaunaAnimInstance::bIsInTornado' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, LookAtAlpha) == 0x000554, "Member 'UFortAIFaunaAnimInstance::LookAtAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, MaxDistanceToPlayerForLookAt) == 0x000558, "Member 'UFortAIFaunaAnimInstance::MaxDistanceToPlayerForLookAt' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, LookAtTooFarFromPlayerTimeOut) == 0x00055C, "Member 'UFortAIFaunaAnimInstance::LookAtTooFarFromPlayerTimeOut' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bDisableLookAtDuringMontage) == 0x000560, "Member 'UFortAIFaunaAnimInstance::bDisableLookAtDuringMontage' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, DisableHeadTrackingCurveName) == 0x000564, "Member 'UFortAIFaunaAnimInstance::DisableHeadTrackingCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, RidingAnimationData) == 0x000568, "Member 'UFortAIFaunaAnimInstance::RidingAnimationData' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Burt
// 0x0090 (0x0610 - 0x0580)
#pragma pack(push, 0x1)
class alignas(0x10) UFortAIFaunaAnimInstance_Burt : public UFortAIFaunaAnimInstance
{
public:
	float                                         MovingPlayRate;                                    // 0x0580(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPoseAdditiveAlpha;                       // 0x0584(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHeadTiltUpAdditive;                         // 0x0588(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnAngleIsNegative;                              // 0x0589(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58A[0x2];                                      // 0x058A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DisableLocomotionAdditiveCurveName;                // 0x058C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InterruptibleCurveName;                            // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIdleShuffleTurn;                                // 0x0594(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_595[0x3];                                      // 0x0595(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleShuffleBodyBend;                               // 0x0598(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRate;                               // 0x059C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleShuffleTurnDirection;                         // 0x05A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoving;                                         // 0x05A1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToApex;                          // 0x05A2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToMoving;                        // 0x05A3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionMovingToIdle;                        // 0x05A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLandToIdle;                          // 0x05A5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLandToJumpStart;                     // 0x05A6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionJumpStartToApex;                     // 0x05A7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionApexToFall;                          // 0x05A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionFallToLand;                          // 0x05A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleTurnToIdle;                      // 0x05AA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLocomotionTurnToIdle;                // 0x05AB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLocomotionTurnToMoving;              // 0x05AC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleTurnToMoving;                    // 0x05AD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionFallToMoving;                        // 0x05AE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionFallToIdle;                          // 0x05AF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_SpeedThreshold;                     // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_SlowSpeedDivisor;                   // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_FastSpeedDivisor;                   // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_MinClamp;                           // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_MaxClamp;                           // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_InterpSpeed;                        // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPoseAdditiveAlpha_InterpSpeed;           // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableHeadTiltUpAdditive_PawnUniqueIDMultiplier;   // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableHeadTiltUpAdditive_ModOperand;               // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterruptibleCurveValue_LargeThreshold;            // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterruptibleCurveValue_TurnAngleThreshold;        // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_MovingThreshold;                             // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_IdleThreshold;                               // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnAngle_LargeThreshold;                          // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleBodyBendMultiplier;                     // 0x05E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnThreshold;                          // 0x05EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnDirectionThreshold;                 // 0x05F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeA;                       // 0x05F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeB;                       // 0x05F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeA;                      // 0x05FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeB;                      // 0x0600(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_604[0x4];                                      // 0x0604(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Burt">();
	}
	static class UFortAIFaunaAnimInstance_Burt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Burt>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortAIFaunaAnimInstance_Burt) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Burt");
static_assert(sizeof(UFortAIFaunaAnimInstance_Burt) == 0x000610, "Wrong size on UFortAIFaunaAnimInstance_Burt");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate) == 0x000580, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, LocomotionPoseAdditiveAlpha) == 0x000584, "Member 'UFortAIFaunaAnimInstance_Burt::LocomotionPoseAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bEnableHeadTiltUpAdditive) == 0x000588, "Member 'UFortAIFaunaAnimInstance_Burt::bEnableHeadTiltUpAdditive' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bTurnAngleIsNegative) == 0x000589, "Member 'UFortAIFaunaAnimInstance_Burt::bTurnAngleIsNegative' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, DisableLocomotionAdditiveCurveName) == 0x00058C, "Member 'UFortAIFaunaAnimInstance_Burt::DisableLocomotionAdditiveCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, InterruptibleCurveName) == 0x000590, "Member 'UFortAIFaunaAnimInstance_Burt::InterruptibleCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bIsIdleShuffleTurn) == 0x000594, "Member 'UFortAIFaunaAnimInstance_Burt::bIsIdleShuffleTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShuffleBodyBend) == 0x000598, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShuffleBodyBend' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShufflePlayRate) == 0x00059C, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShufflePlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bIdleShuffleTurnDirection) == 0x0005A0, "Member 'UFortAIFaunaAnimInstance_Burt::bIdleShuffleTurnDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bIsMoving) == 0x0005A1, "Member 'UFortAIFaunaAnimInstance_Burt::bIsMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionIdleToApex) == 0x0005A2, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionIdleToApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionIdleToMoving) == 0x0005A3, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionIdleToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionMovingToIdle) == 0x0005A4, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionMovingToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionLandToIdle) == 0x0005A5, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionLandToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionLandToJumpStart) == 0x0005A6, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionLandToJumpStart' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionJumpStartToApex) == 0x0005A7, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionJumpStartToApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionApexToFall) == 0x0005A8, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionApexToFall' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionFallToLand) == 0x0005A9, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionFallToLand' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionIdleTurnToIdle) == 0x0005AA, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionIdleTurnToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionLocomotionTurnToIdle) == 0x0005AB, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionLocomotionTurnToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionLocomotionTurnToMoving) == 0x0005AC, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionLocomotionTurnToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionIdleTurnToMoving) == 0x0005AD, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionIdleTurnToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionFallToMoving) == 0x0005AE, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionFallToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionFallToIdle) == 0x0005AF, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionFallToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_SpeedThreshold) == 0x0005B0, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_SlowSpeedDivisor) == 0x0005B4, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_SlowSpeedDivisor' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_FastSpeedDivisor) == 0x0005B8, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_FastSpeedDivisor' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_MinClamp) == 0x0005BC, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_MinClamp' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_MaxClamp) == 0x0005C0, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_MaxClamp' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_InterpSpeed) == 0x0005C4, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_InterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, LocomotionPoseAdditiveAlpha_InterpSpeed) == 0x0005C8, "Member 'UFortAIFaunaAnimInstance_Burt::LocomotionPoseAdditiveAlpha_InterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, EnableHeadTiltUpAdditive_PawnUniqueIDMultiplier) == 0x0005CC, "Member 'UFortAIFaunaAnimInstance_Burt::EnableHeadTiltUpAdditive_PawnUniqueIDMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, EnableHeadTiltUpAdditive_ModOperand) == 0x0005D0, "Member 'UFortAIFaunaAnimInstance_Burt::EnableHeadTiltUpAdditive_ModOperand' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, InterruptibleCurveValue_LargeThreshold) == 0x0005D4, "Member 'UFortAIFaunaAnimInstance_Burt::InterruptibleCurveValue_LargeThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, InterruptibleCurveValue_TurnAngleThreshold) == 0x0005D8, "Member 'UFortAIFaunaAnimInstance_Burt::InterruptibleCurveValue_TurnAngleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, Speed_MovingThreshold) == 0x0005DC, "Member 'UFortAIFaunaAnimInstance_Burt::Speed_MovingThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, Speed_IdleThreshold) == 0x0005E0, "Member 'UFortAIFaunaAnimInstance_Burt::Speed_IdleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, TurnAngle_LargeThreshold) == 0x0005E4, "Member 'UFortAIFaunaAnimInstance_Burt::TurnAngle_LargeThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShuffleBodyBendMultiplier) == 0x0005E8, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShuffleBodyBendMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShuffleTurnThreshold) == 0x0005EC, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShuffleTurnThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShuffleTurnDirectionThreshold) == 0x0005F0, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShuffleTurnDirectionThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShufflePlayRateInRangeA) == 0x0005F4, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShufflePlayRateInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShufflePlayRateInRangeB) == 0x0005F8, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShufflePlayRateInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShufflePlayRateOutRangeA) == 0x0005FC, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShufflePlayRateOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShufflePlayRateOutRangeB) == 0x000600, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShufflePlayRateOutRangeB' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Burt_Hitchhiker
// 0x0000 (0x0610 - 0x0610)
class UFortAIFaunaAnimInstance_Burt_Hitchhiker final : public UFortAIFaunaAnimInstance_Burt
{
public:
	bool                                          IsFloating;                                        // 0x0608(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInTractorBeam;                                   // 0x0609(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHitchhiked;                                      // 0x060A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60B[0x5];                                      // 0x060B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Burt_Hitchhiker">();
	}
	static class UFortAIFaunaAnimInstance_Burt_Hitchhiker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Burt_Hitchhiker>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Burt_Hitchhiker) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Burt_Hitchhiker");
static_assert(sizeof(UFortAIFaunaAnimInstance_Burt_Hitchhiker) == 0x000610, "Wrong size on UFortAIFaunaAnimInstance_Burt_Hitchhiker");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt_Hitchhiker, IsFloating) == 0x000608, "Member 'UFortAIFaunaAnimInstance_Burt_Hitchhiker::IsFloating' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt_Hitchhiker, IsInTractorBeam) == 0x000609, "Member 'UFortAIFaunaAnimInstance_Burt_Hitchhiker::IsInTractorBeam' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt_Hitchhiker, IsHitchhiked) == 0x00060A, "Member 'UFortAIFaunaAnimInstance_Burt_Hitchhiker::IsHitchhiked' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Crow
// 0x0030 (0x05B0 - 0x0580)
class UFortAIFaunaAnimInstance_Crow final : public UFortAIFaunaAnimInstance
{
public:
	float                                         WingFlapPlayRate;                                  // 0x0580(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDescending;                                     // 0x0584(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGliding;                                        // 0x0585(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFlying;                                         // 0x0586(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFlyingSlow;                                     // 0x0587(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLanding;                                        // 0x0588(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_589[0x3];                                      // 0x0589(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WingFlapPlayRateInRangeA;                          // 0x058C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WingFlapPlayRateInRangeB;                          // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WingFlapPlayRateOutRangeA;                         // 0x0594(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WingFlapPlayRateOutRangeB;                         // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZVelocityDescendingThreshold;                      // 0x059C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlidingSpeedThreshold;                             // 0x05A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyingSpeedThreshold;                              // 0x05A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyingSlowSpeedThreshold;                          // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandingSpeedThreshold;                             // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Crow">();
	}
	static class UFortAIFaunaAnimInstance_Crow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Crow>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Crow) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Crow");
static_assert(sizeof(UFortAIFaunaAnimInstance_Crow) == 0x0005B0, "Wrong size on UFortAIFaunaAnimInstance_Crow");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, WingFlapPlayRate) == 0x000580, "Member 'UFortAIFaunaAnimInstance_Crow::WingFlapPlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, bIsDescending) == 0x000584, "Member 'UFortAIFaunaAnimInstance_Crow::bIsDescending' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, bIsGliding) == 0x000585, "Member 'UFortAIFaunaAnimInstance_Crow::bIsGliding' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, bIsFlying) == 0x000586, "Member 'UFortAIFaunaAnimInstance_Crow::bIsFlying' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, bIsFlyingSlow) == 0x000587, "Member 'UFortAIFaunaAnimInstance_Crow::bIsFlyingSlow' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, bIsLanding) == 0x000588, "Member 'UFortAIFaunaAnimInstance_Crow::bIsLanding' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, WingFlapPlayRateInRangeA) == 0x00058C, "Member 'UFortAIFaunaAnimInstance_Crow::WingFlapPlayRateInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, WingFlapPlayRateInRangeB) == 0x000590, "Member 'UFortAIFaunaAnimInstance_Crow::WingFlapPlayRateInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, WingFlapPlayRateOutRangeA) == 0x000594, "Member 'UFortAIFaunaAnimInstance_Crow::WingFlapPlayRateOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, WingFlapPlayRateOutRangeB) == 0x000598, "Member 'UFortAIFaunaAnimInstance_Crow::WingFlapPlayRateOutRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, ZVelocityDescendingThreshold) == 0x00059C, "Member 'UFortAIFaunaAnimInstance_Crow::ZVelocityDescendingThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, GlidingSpeedThreshold) == 0x0005A0, "Member 'UFortAIFaunaAnimInstance_Crow::GlidingSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, FlyingSpeedThreshold) == 0x0005A4, "Member 'UFortAIFaunaAnimInstance_Crow::FlyingSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, FlyingSlowSpeedThreshold) == 0x0005A8, "Member 'UFortAIFaunaAnimInstance_Crow::FlyingSlowSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, LandingSpeedThreshold) == 0x0005AC, "Member 'UFortAIFaunaAnimInstance_Crow::LandingSpeedThreshold' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Grandma
// 0x00B0 (0x0630 - 0x0580)
class UFortAIFaunaAnimInstance_Grandma : public UFortAIFaunaAnimInstance
{
public:
	class AFortAIPawn*                            AIPawn;                                            // 0x0580(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshScale;                                         // 0x0588(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldPlayFullBodyInPlace;                        // 0x058C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58D[0x3];                                      // 0x058D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlinkAlpha;                                        // 0x0590(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkRunPlayRate;                                   // 0x0594(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPoseAdditiveAlpha;                       // 0x0598(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSniffAdditive;                              // 0x059C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAlertAdditive;                              // 0x059D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleStartTurn;                                    // 0x059E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookAtAdditiveTurnAlpha;                          // 0x059F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIdleShuffleTurn;                                // 0x05A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A1[0x3];                                      // 0x05A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleShuffleBodyBend;                               // 0x05A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRate;                               // 0x05A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleShuffleTurnDirection;                         // 0x05AC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5AD[0x3];                                      // 0x05AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeedFullBodyInPlace;                           // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCurveValueFullBodyInPlace;                      // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPoseAdditiveAlphaInterpRate;             // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SniffAdditiveFrequenceySeconds;                    // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AlertAdditiveFrequenceySeconds;                    // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PawnIDScale;                                       // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShouldPlayFullBodyInPlaceCurveName;                // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BlinkAlphaCurveName;                               // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleStartTurnInterruptibleThreshold;               // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleBodyBendMultiplier;                     // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnThreshold;                          // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnDirectionThreshold;                 // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtAdditiveTurnAlphaThreshold;                  // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeA;                       // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeB;                       // 0x05E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeA;                      // 0x05EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeB;                      // 0x05F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovingOnGroundORIsSurfaceSwimming;              // 0x05F4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_DefaultJump_ToJumpApex;                 // 0x05F5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnIdle_Idle;                          // 0x05F6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnIdle_Moving;                        // 0x05F7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Moving_TurnIdle;                        // 0x05F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnMoving_Moving;                      // 0x05F9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Moving_TurnMoving;                      // 0x05FA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Idle_Moving;                            // 0x05FB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Moving_Idle;                            // 0x05FC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_JumpLand_Idle;                          // 0x05FD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_JumpLand_Moving;                        // 0x05FE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_JumpStart_JumpApex;                     // 0x05FF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Fall_Moving;                            // 0x0600(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Fall_Idle;                              // 0x0601(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimIdle_SwimLoco;                      // 0x0602(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimLoco_SwimIdle;                      // 0x0603(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimTurn_SwimIdle;                      // 0x0604(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimTurn_SwimLoco;                      // 0x0605(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimRule_NegativeTurnAngle;                       // 0x0606(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_607[0x1];                                      // 0x0607(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterruptibleMaxCheck;                             // 0x0608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedStopTransition;                               // 0x060C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedIdleMoveTransition;                           // 0x0610(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMovingTurnIdleTransition;                     // 0x0614(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedToMoveMin;                                    // 0x0618(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StateTimeFromEndThreshold;                         // 0x061C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedIdleStartTurnThreshold;                       // 0x0620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedFallMovingThreshold;                          // 0x0624(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_628[0x8];                                      // 0x0628(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalculateBlinkAlpha();
	float CalculateLocomotionPoseAlpha();
	float CalculateMeshScale();
	float CalculateWalkRunPlayRate();
	bool DetermineEnableAlertAdditive();
	bool DetermineEnableSniffAdditive();
	bool DetermineIdleStartTurn();
	bool DetermineShouldPlayFullBodyInPlace();
	void UpdateBlinkAlpha();
	void UpdateEnableAlertAdditive();
	void UpdateEnableSniffAdditive();
	void UpdateIdleStartTurn();
	void UpdateLocomotionPoseAlpha();
	void UpdateMeshScale();
	void UpdateMovingRates();
	void UpdateShouldPlayFullBodyInPlace();
	void UpdateStateVariables();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Grandma">();
	}
	static class UFortAIFaunaAnimInstance_Grandma* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Grandma>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Grandma) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Grandma");
static_assert(sizeof(UFortAIFaunaAnimInstance_Grandma) == 0x000630, "Wrong size on UFortAIFaunaAnimInstance_Grandma");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, AIPawn) == 0x000580, "Member 'UFortAIFaunaAnimInstance_Grandma::AIPawn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, MeshScale) == 0x000588, "Member 'UFortAIFaunaAnimInstance_Grandma::MeshScale' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bShouldPlayFullBodyInPlace) == 0x00058C, "Member 'UFortAIFaunaAnimInstance_Grandma::bShouldPlayFullBodyInPlace' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, BlinkAlpha) == 0x000590, "Member 'UFortAIFaunaAnimInstance_Grandma::BlinkAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, WalkRunPlayRate) == 0x000594, "Member 'UFortAIFaunaAnimInstance_Grandma::WalkRunPlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, LocomotionPoseAdditiveAlpha) == 0x000598, "Member 'UFortAIFaunaAnimInstance_Grandma::LocomotionPoseAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bEnableSniffAdditive) == 0x00059C, "Member 'UFortAIFaunaAnimInstance_Grandma::bEnableSniffAdditive' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bEnableAlertAdditive) == 0x00059D, "Member 'UFortAIFaunaAnimInstance_Grandma::bEnableAlertAdditive' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bIdleStartTurn) == 0x00059E, "Member 'UFortAIFaunaAnimInstance_Grandma::bIdleStartTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bLookAtAdditiveTurnAlpha) == 0x00059F, "Member 'UFortAIFaunaAnimInstance_Grandma::bLookAtAdditiveTurnAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bIsIdleShuffleTurn) == 0x0005A0, "Member 'UFortAIFaunaAnimInstance_Grandma::bIsIdleShuffleTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShuffleBodyBend) == 0x0005A4, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShuffleBodyBend' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShufflePlayRate) == 0x0005A8, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShufflePlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bIdleShuffleTurnDirection) == 0x0005AC, "Member 'UFortAIFaunaAnimInstance_Grandma::bIdleShuffleTurnDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, MaxSpeedFullBodyInPlace) == 0x0005B0, "Member 'UFortAIFaunaAnimInstance_Grandma::MaxSpeedFullBodyInPlace' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, MinCurveValueFullBodyInPlace) == 0x0005B4, "Member 'UFortAIFaunaAnimInstance_Grandma::MinCurveValueFullBodyInPlace' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, LocomotionPoseAdditiveAlphaInterpRate) == 0x0005B8, "Member 'UFortAIFaunaAnimInstance_Grandma::LocomotionPoseAdditiveAlphaInterpRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SniffAdditiveFrequenceySeconds) == 0x0005BC, "Member 'UFortAIFaunaAnimInstance_Grandma::SniffAdditiveFrequenceySeconds' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, AlertAdditiveFrequenceySeconds) == 0x0005C0, "Member 'UFortAIFaunaAnimInstance_Grandma::AlertAdditiveFrequenceySeconds' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, PawnIDScale) == 0x0005C4, "Member 'UFortAIFaunaAnimInstance_Grandma::PawnIDScale' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, ShouldPlayFullBodyInPlaceCurveName) == 0x0005C8, "Member 'UFortAIFaunaAnimInstance_Grandma::ShouldPlayFullBodyInPlaceCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, BlinkAlphaCurveName) == 0x0005CC, "Member 'UFortAIFaunaAnimInstance_Grandma::BlinkAlphaCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleStartTurnInterruptibleThreshold) == 0x0005D0, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleStartTurnInterruptibleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShuffleBodyBendMultiplier) == 0x0005D4, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShuffleBodyBendMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShuffleTurnThreshold) == 0x0005D8, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShuffleTurnThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShuffleTurnDirectionThreshold) == 0x0005DC, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShuffleTurnDirectionThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, LookAtAdditiveTurnAlphaThreshold) == 0x0005E0, "Member 'UFortAIFaunaAnimInstance_Grandma::LookAtAdditiveTurnAlphaThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShufflePlayRateInRangeA) == 0x0005E4, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShufflePlayRateInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShufflePlayRateInRangeB) == 0x0005E8, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShufflePlayRateInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShufflePlayRateOutRangeA) == 0x0005EC, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShufflePlayRateOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShufflePlayRateOutRangeB) == 0x0005F0, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShufflePlayRateOutRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bIsMovingOnGroundORIsSurfaceSwimming) == 0x0005F4, "Member 'UFortAIFaunaAnimInstance_Grandma::bIsMovingOnGroundORIsSurfaceSwimming' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_DefaultJump_ToJumpApex) == 0x0005F5, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_DefaultJump_ToJumpApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_TurnIdle_Idle) == 0x0005F6, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_TurnIdle_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_TurnIdle_Moving) == 0x0005F7, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_TurnIdle_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Moving_TurnIdle) == 0x0005F8, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Moving_TurnIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_TurnMoving_Moving) == 0x0005F9, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_TurnMoving_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Moving_TurnMoving) == 0x0005FA, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Moving_TurnMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Idle_Moving) == 0x0005FB, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Idle_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Moving_Idle) == 0x0005FC, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Moving_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_JumpLand_Idle) == 0x0005FD, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_JumpLand_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_JumpLand_Moving) == 0x0005FE, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_JumpLand_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_JumpStart_JumpApex) == 0x0005FF, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_JumpStart_JumpApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Fall_Moving) == 0x000600, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Fall_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Fall_Idle) == 0x000601, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Fall_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_SwimIdle_SwimLoco) == 0x000602, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_SwimIdle_SwimLoco' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_SwimLoco_SwimIdle) == 0x000603, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_SwimLoco_SwimIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_SwimTurn_SwimIdle) == 0x000604, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_SwimTurn_SwimIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_SwimTurn_SwimLoco) == 0x000605, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_SwimTurn_SwimLoco' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bAnimRule_NegativeTurnAngle) == 0x000606, "Member 'UFortAIFaunaAnimInstance_Grandma::bAnimRule_NegativeTurnAngle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, InterruptibleMaxCheck) == 0x000608, "Member 'UFortAIFaunaAnimInstance_Grandma::InterruptibleMaxCheck' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedStopTransition) == 0x00060C, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedStopTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedIdleMoveTransition) == 0x000610, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedIdleMoveTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedMovingTurnIdleTransition) == 0x000614, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedMovingTurnIdleTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedToMoveMin) == 0x000618, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedToMoveMin' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, StateTimeFromEndThreshold) == 0x00061C, "Member 'UFortAIFaunaAnimInstance_Grandma::StateTimeFromEndThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedIdleStartTurnThreshold) == 0x000620, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedIdleStartTurnThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedFallMovingThreshold) == 0x000624, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedFallMovingThreshold' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Grandma_Hitchhiker
// 0x0010 (0x0640 - 0x0630)
class UFortAIFaunaAnimInstance_Grandma_Hitchhiker final : public UFortAIFaunaAnimInstance_Grandma
{
public:
	bool                                          bIsHitchhiked;                                     // 0x0630(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGrandmaSprinting;                               // 0x0631(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFloating;                                       // 0x0632(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInTractorBeam;                                  // 0x0633(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintCheckSpeed;                                  // 0x0634(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_638[0x8];                                      // 0x0638(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Grandma_Hitchhiker">();
	}
	static class UFortAIFaunaAnimInstance_Grandma_Hitchhiker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Grandma_Hitchhiker>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Grandma_Hitchhiker");
static_assert(sizeof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker) == 0x000640, "Wrong size on UFortAIFaunaAnimInstance_Grandma_Hitchhiker");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker, bIsHitchhiked) == 0x000630, "Member 'UFortAIFaunaAnimInstance_Grandma_Hitchhiker::bIsHitchhiked' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker, bIsGrandmaSprinting) == 0x000631, "Member 'UFortAIFaunaAnimInstance_Grandma_Hitchhiker::bIsGrandmaSprinting' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker, bIsFloating) == 0x000632, "Member 'UFortAIFaunaAnimInstance_Grandma_Hitchhiker::bIsFloating' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker, bIsInTractorBeam) == 0x000633, "Member 'UFortAIFaunaAnimInstance_Grandma_Hitchhiker::bIsInTractorBeam' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker, SprintCheckSpeed) == 0x000634, "Member 'UFortAIFaunaAnimInstance_Grandma_Hitchhiker::SprintCheckSpeed' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Nug
// 0x0090 (0x0610 - 0x0580)
class UFortAIFaunaAnimInstance_Nug : public UFortAIFaunaAnimInstance
{
public:
	bool                                          bIsBeingHeld;                                      // 0x0580(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBeingThrown;                                    // 0x0581(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_582[0x2];                                      // 0x0582(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LowerBodyMaskAlpha;                                // 0x0584(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldExitJump;                                   // 0x0588(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_589[0x3];                                      // 0x0589(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovingPlayRate;                                    // 0x058C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldLean;                                       // 0x0590(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_591[0x3];                                      // 0x0591(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeanDirection;                                     // 0x0594(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnAngleIsNegative;                              // 0x0598(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_599[0x3];                                      // 0x0599(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InterruptibleCurveName;                            // 0x059C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIdleShuffleTurn;                                // 0x05A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A1[0x3];                                      // 0x05A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleShuffleBodyBend;                               // 0x05A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRate;                               // 0x05A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleShuffleTurnDirection;                         // 0x05AC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToIdleTurn;                      // 0x05AD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToLocomotionTurn;                // 0x05AE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToMoving;                        // 0x05AF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToJumpApex;                      // 0x05B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionMovingToIdle;                        // 0x05B1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionJumpStartToJumpApex;                 // 0x05B2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionJumpApexToJumpLoop;                  // 0x05B3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLocomotionTurnToIdle;                // 0x05B4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLocomotionTurnToMoving;              // 0x05B5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleTurnToMoving;                    // 0x05B6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleTurnToIdle;                      // 0x05B7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionJumpLoopToJumpLand;                  // 0x05B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIsBeingHeldToChickenChuck;           // 0x05B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5BA[0x2];                                      // 0x05BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShouldExitJump_SpeedThreshold;                     // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_SpeedThreshold;                     // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_SlowSpeedDivisor;                   // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_FastSpeedDivisor;                   // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_InterpSpeed;                        // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_MinClamp;                           // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_MaxClamp;                           // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanDirection_SpeedThreshold;                      // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShouldLean_SpeedThreshold;                         // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterruptibleCurveValue_LargeThreshold;            // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_MovingThreshold;                             // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_IdleThreshold;                               // 0x05E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleTurnTransition_SpeedThreshold;                 // 0x05EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionTurnTransition_SpeedThreshold;           // 0x05F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleBodyBendMultiplier;                     // 0x05F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnThreshold;                          // 0x05F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnDirectionThreshold;                 // 0x05FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeA;                       // 0x0600(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeB;                       // 0x0604(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeA;                      // 0x0608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeB;                      // 0x060C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Nug">();
	}
	static class UFortAIFaunaAnimInstance_Nug* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Nug>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Nug) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Nug");
static_assert(sizeof(UFortAIFaunaAnimInstance_Nug) == 0x000610, "Wrong size on UFortAIFaunaAnimInstance_Nug");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bIsBeingHeld) == 0x000580, "Member 'UFortAIFaunaAnimInstance_Nug::bIsBeingHeld' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bIsBeingThrown) == 0x000581, "Member 'UFortAIFaunaAnimInstance_Nug::bIsBeingThrown' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, LowerBodyMaskAlpha) == 0x000584, "Member 'UFortAIFaunaAnimInstance_Nug::LowerBodyMaskAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bShouldExitJump) == 0x000588, "Member 'UFortAIFaunaAnimInstance_Nug::bShouldExitJump' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate) == 0x00058C, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bShouldLean) == 0x000590, "Member 'UFortAIFaunaAnimInstance_Nug::bShouldLean' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, LeanDirection) == 0x000594, "Member 'UFortAIFaunaAnimInstance_Nug::LeanDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bTurnAngleIsNegative) == 0x000598, "Member 'UFortAIFaunaAnimInstance_Nug::bTurnAngleIsNegative' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, InterruptibleCurveName) == 0x00059C, "Member 'UFortAIFaunaAnimInstance_Nug::InterruptibleCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bIsIdleShuffleTurn) == 0x0005A0, "Member 'UFortAIFaunaAnimInstance_Nug::bIsIdleShuffleTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShuffleBodyBend) == 0x0005A4, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShuffleBodyBend' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShufflePlayRate) == 0x0005A8, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShufflePlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bIdleShuffleTurnDirection) == 0x0005AC, "Member 'UFortAIFaunaAnimInstance_Nug::bIdleShuffleTurnDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleToIdleTurn) == 0x0005AD, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleToIdleTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleToLocomotionTurn) == 0x0005AE, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleToLocomotionTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleToMoving) == 0x0005AF, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleToJumpApex) == 0x0005B0, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleToJumpApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionMovingToIdle) == 0x0005B1, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionMovingToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionJumpStartToJumpApex) == 0x0005B2, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionJumpStartToJumpApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionJumpApexToJumpLoop) == 0x0005B3, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionJumpApexToJumpLoop' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionLocomotionTurnToIdle) == 0x0005B4, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionLocomotionTurnToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionLocomotionTurnToMoving) == 0x0005B5, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionLocomotionTurnToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleTurnToMoving) == 0x0005B6, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleTurnToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleTurnToIdle) == 0x0005B7, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleTurnToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionJumpLoopToJumpLand) == 0x0005B8, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionJumpLoopToJumpLand' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIsBeingHeldToChickenChuck) == 0x0005B9, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIsBeingHeldToChickenChuck' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, ShouldExitJump_SpeedThreshold) == 0x0005BC, "Member 'UFortAIFaunaAnimInstance_Nug::ShouldExitJump_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_SpeedThreshold) == 0x0005C0, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_SlowSpeedDivisor) == 0x0005C4, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_SlowSpeedDivisor' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_FastSpeedDivisor) == 0x0005C8, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_FastSpeedDivisor' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_InterpSpeed) == 0x0005CC, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_InterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_MinClamp) == 0x0005D0, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_MinClamp' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_MaxClamp) == 0x0005D4, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_MaxClamp' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, LeanDirection_SpeedThreshold) == 0x0005D8, "Member 'UFortAIFaunaAnimInstance_Nug::LeanDirection_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, ShouldLean_SpeedThreshold) == 0x0005DC, "Member 'UFortAIFaunaAnimInstance_Nug::ShouldLean_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, InterruptibleCurveValue_LargeThreshold) == 0x0005E0, "Member 'UFortAIFaunaAnimInstance_Nug::InterruptibleCurveValue_LargeThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, Speed_MovingThreshold) == 0x0005E4, "Member 'UFortAIFaunaAnimInstance_Nug::Speed_MovingThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, Speed_IdleThreshold) == 0x0005E8, "Member 'UFortAIFaunaAnimInstance_Nug::Speed_IdleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleTurnTransition_SpeedThreshold) == 0x0005EC, "Member 'UFortAIFaunaAnimInstance_Nug::IdleTurnTransition_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, LocomotionTurnTransition_SpeedThreshold) == 0x0005F0, "Member 'UFortAIFaunaAnimInstance_Nug::LocomotionTurnTransition_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShuffleBodyBendMultiplier) == 0x0005F4, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShuffleBodyBendMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShuffleTurnThreshold) == 0x0005F8, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShuffleTurnThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShuffleTurnDirectionThreshold) == 0x0005FC, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShuffleTurnDirectionThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShufflePlayRateInRangeA) == 0x000600, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShufflePlayRateInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShufflePlayRateInRangeB) == 0x000604, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShufflePlayRateInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShufflePlayRateOutRangeA) == 0x000608, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShufflePlayRateOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShufflePlayRateOutRangeB) == 0x00060C, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShufflePlayRateOutRangeB' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Nug_Hitchhiker
// 0x0010 (0x0620 - 0x0610)
class UFortAIFaunaAnimInstance_Nug_Hitchhiker final : public UFortAIFaunaAnimInstance_Nug
{
public:
	bool                                          bIsSwimming;                                       // 0x0610(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInTractorBeam;                                  // 0x0611(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFloating;                                       // 0x0612(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHitchhiked;                                     // 0x0613(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_614[0xC];                                      // 0x0614(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Nug_Hitchhiker">();
	}
	static class UFortAIFaunaAnimInstance_Nug_Hitchhiker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Nug_Hitchhiker>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Nug_Hitchhiker) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Nug_Hitchhiker");
static_assert(sizeof(UFortAIFaunaAnimInstance_Nug_Hitchhiker) == 0x000620, "Wrong size on UFortAIFaunaAnimInstance_Nug_Hitchhiker");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug_Hitchhiker, bIsSwimming) == 0x000610, "Member 'UFortAIFaunaAnimInstance_Nug_Hitchhiker::bIsSwimming' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug_Hitchhiker, bIsInTractorBeam) == 0x000611, "Member 'UFortAIFaunaAnimInstance_Nug_Hitchhiker::bIsInTractorBeam' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug_Hitchhiker, bIsFloating) == 0x000612, "Member 'UFortAIFaunaAnimInstance_Nug_Hitchhiker::bIsFloating' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug_Hitchhiker, bIsHitchhiked) == 0x000613, "Member 'UFortAIFaunaAnimInstance_Nug_Hitchhiker::bIsHitchhiked' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Robert
// 0x0090 (0x0610 - 0x0580)
class UFortAIFaunaAnimInstance_Robert final : public UFortAIFaunaAnimInstance
{
public:
	uint8                                         Pad_580[0x8];                                      // 0x0580(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortAIPawn*                            AIPawn;                                            // 0x0588(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleStartTurn;                                    // 0x0590(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHeadTiltDownAdditive;                       // 0x0591(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFullBodyInPlace;                                // 0x0592(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_593[0x1];                                      // 0x0593(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocomotionPoseAdditiveAlpha;                       // 0x0594(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIdleShuffleTurn;                                // 0x0598(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_599[0x3];                                      // 0x0599(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleShuffleBodyBend;                               // 0x059C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRate;                               // 0x05A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleShuffleTurnDirection;                         // 0x05A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFloating;                                       // 0x05A5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInTractorBeam;                                  // 0x05A6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookAtAdditiveTurnAlpha;                          // 0x05A7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnDirection;                                    // 0x05A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A9[0x3];                                      // 0x05A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PawnIDScale;                                       // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeadTiltDownAdditiveFrequenceySeconds;             // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceFullBodyTransition;                           // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPoseAdditiveAlphaInterpRate;             // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleStartTurnInterruptibleThreshold;               // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtAlphaThreshold;                              // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMovingThreshold;                              // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnDirectionThreshold;                            // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleBodyBendMultiplier;                     // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnThreshold;                          // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnDirectionThreshold;                 // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeA;                       // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeB;                       // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeA;                      // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeB;                      // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnIdle_Idle;                          // 0x05E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Idle_TurnIdle;                          // 0x05E9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnIdle_Moving;                        // 0x05EA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnMoving_TurnIdle;                    // 0x05EB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Idle_Moving;                            // 0x05EC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Moving_Idle;                            // 0x05ED(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnMoving_Moving;                      // 0x05EE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Moving_TurnMoving;                      // 0x05EF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Swimming_Fall;                          // 0x05F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Land_Idle;                              // 0x05F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_JumpStart_Apex;                         // 0x05F2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Fall_Idle;                              // 0x05F3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Fall_Moving;                            // 0x05F4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimIdle_SwimLoco;                      // 0x05F5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimLoco_SwimIdle;                      // 0x05F6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimTurn_SwimIdle;                      // 0x05F7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimTurn_SwimLoco;                      // 0x05F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimRule_NegativeTurnAngle;                       // 0x05F9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5FA[0x2];                                      // 0x05FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterruptibleMaxCheck;                             // 0x05FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedStopTransition;                               // 0x0600(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedIdleMoveTransition;                           // 0x0604(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedToMoveMin;                                    // 0x0608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StateTimeFromEndThreshold;                         // 0x060C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	float CalculateLocomotionPoseAdditiveAlpha();
	bool DetermineEnableHeadTiltDownAdditive();
	bool DetermineIdleStartTurn();
	bool DetermineIsFullBodyInPlace();
	void UpdateEnableHeadTiltDownAdditive();
	void UpdateIdleStartTurn();
	void UpdateIsFullBodyInPlace();
	void UpdateLocomotionPoseAdditiveAlpha();
	void UpdateStateVariables();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Robert">();
	}
	static class UFortAIFaunaAnimInstance_Robert* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Robert>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Robert) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Robert");
static_assert(sizeof(UFortAIFaunaAnimInstance_Robert) == 0x000610, "Wrong size on UFortAIFaunaAnimInstance_Robert");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AIPawn) == 0x000588, "Member 'UFortAIFaunaAnimInstance_Robert::AIPawn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIdleStartTurn) == 0x000590, "Member 'UFortAIFaunaAnimInstance_Robert::bIdleStartTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bEnableHeadTiltDownAdditive) == 0x000591, "Member 'UFortAIFaunaAnimInstance_Robert::bEnableHeadTiltDownAdditive' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIsFullBodyInPlace) == 0x000592, "Member 'UFortAIFaunaAnimInstance_Robert::bIsFullBodyInPlace' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, LocomotionPoseAdditiveAlpha) == 0x000594, "Member 'UFortAIFaunaAnimInstance_Robert::LocomotionPoseAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIsIdleShuffleTurn) == 0x000598, "Member 'UFortAIFaunaAnimInstance_Robert::bIsIdleShuffleTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShuffleBodyBend) == 0x00059C, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShuffleBodyBend' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShufflePlayRate) == 0x0005A0, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShufflePlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIdleShuffleTurnDirection) == 0x0005A4, "Member 'UFortAIFaunaAnimInstance_Robert::bIdleShuffleTurnDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIsFloating) == 0x0005A5, "Member 'UFortAIFaunaAnimInstance_Robert::bIsFloating' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIsInTractorBeam) == 0x0005A6, "Member 'UFortAIFaunaAnimInstance_Robert::bIsInTractorBeam' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bLookAtAdditiveTurnAlpha) == 0x0005A7, "Member 'UFortAIFaunaAnimInstance_Robert::bLookAtAdditiveTurnAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bTurnDirection) == 0x0005A8, "Member 'UFortAIFaunaAnimInstance_Robert::bTurnDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, PawnIDScale) == 0x0005AC, "Member 'UFortAIFaunaAnimInstance_Robert::PawnIDScale' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, HeadTiltDownAdditiveFrequenceySeconds) == 0x0005B0, "Member 'UFortAIFaunaAnimInstance_Robert::HeadTiltDownAdditiveFrequenceySeconds' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, ForceFullBodyTransition) == 0x0005B4, "Member 'UFortAIFaunaAnimInstance_Robert::ForceFullBodyTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, LocomotionPoseAdditiveAlphaInterpRate) == 0x0005B8, "Member 'UFortAIFaunaAnimInstance_Robert::LocomotionPoseAdditiveAlphaInterpRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleStartTurnInterruptibleThreshold) == 0x0005BC, "Member 'UFortAIFaunaAnimInstance_Robert::IdleStartTurnInterruptibleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, LookAtAlphaThreshold) == 0x0005C0, "Member 'UFortAIFaunaAnimInstance_Robert::LookAtAlphaThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SpeedMovingThreshold) == 0x0005C4, "Member 'UFortAIFaunaAnimInstance_Robert::SpeedMovingThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, TurnDirectionThreshold) == 0x0005C8, "Member 'UFortAIFaunaAnimInstance_Robert::TurnDirectionThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShuffleBodyBendMultiplier) == 0x0005CC, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShuffleBodyBendMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShuffleTurnThreshold) == 0x0005D0, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShuffleTurnThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShuffleTurnDirectionThreshold) == 0x0005D4, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShuffleTurnDirectionThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShufflePlayRateInRangeA) == 0x0005D8, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShufflePlayRateInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShufflePlayRateInRangeB) == 0x0005DC, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShufflePlayRateInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShufflePlayRateOutRangeA) == 0x0005E0, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShufflePlayRateOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShufflePlayRateOutRangeB) == 0x0005E4, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShufflePlayRateOutRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_TurnIdle_Idle) == 0x0005E8, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_TurnIdle_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Idle_TurnIdle) == 0x0005E9, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Idle_TurnIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_TurnIdle_Moving) == 0x0005EA, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_TurnIdle_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_TurnMoving_TurnIdle) == 0x0005EB, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_TurnMoving_TurnIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Idle_Moving) == 0x0005EC, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Idle_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Moving_Idle) == 0x0005ED, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Moving_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_TurnMoving_Moving) == 0x0005EE, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_TurnMoving_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Moving_TurnMoving) == 0x0005EF, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Moving_TurnMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Swimming_Fall) == 0x0005F0, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Swimming_Fall' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Land_Idle) == 0x0005F1, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Land_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_JumpStart_Apex) == 0x0005F2, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_JumpStart_Apex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Fall_Idle) == 0x0005F3, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Fall_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Fall_Moving) == 0x0005F4, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Fall_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_SwimIdle_SwimLoco) == 0x0005F5, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_SwimIdle_SwimLoco' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_SwimLoco_SwimIdle) == 0x0005F6, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_SwimLoco_SwimIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_SwimTurn_SwimIdle) == 0x0005F7, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_SwimTurn_SwimIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_SwimTurn_SwimLoco) == 0x0005F8, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_SwimTurn_SwimLoco' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bAnimRule_NegativeTurnAngle) == 0x0005F9, "Member 'UFortAIFaunaAnimInstance_Robert::bAnimRule_NegativeTurnAngle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, InterruptibleMaxCheck) == 0x0005FC, "Member 'UFortAIFaunaAnimInstance_Robert::InterruptibleMaxCheck' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SpeedStopTransition) == 0x000600, "Member 'UFortAIFaunaAnimInstance_Robert::SpeedStopTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SpeedIdleMoveTransition) == 0x000604, "Member 'UFortAIFaunaAnimInstance_Robert::SpeedIdleMoveTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SpeedToMoveMin) == 0x000608, "Member 'UFortAIFaunaAnimInstance_Robert::SpeedToMoveMin' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, StateTimeFromEndThreshold) == 0x00060C, "Member 'UFortAIFaunaAnimInstance_Robert::StateTimeFromEndThreshold' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Smackie
// 0x0040 (0x05C0 - 0x0580)
class UFortAIFaunaAnimInstance_Smackie final : public UFortAIFaunaAnimInstance
{
public:
	bool                                          bIsIdleShuffleTurn;                                // 0x0580(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_581[0x3];                                      // 0x0581(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleShuffleBodyBend;                               // 0x0584(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRate;                               // 0x0588(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleShuffleTurnDirection;                         // 0x058C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToHop;                           // 0x058D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionHopToIdle;                           // 0x058E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionFallToIdle;                          // 0x058F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionFallToHop;                           // 0x0590(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_591[0x3];                                      // 0x0591(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedThreshold;                                    // 0x0594(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleBodyBendMultiplier;                     // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnThreshold;                          // 0x059C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnDirectionThreshold;                 // 0x05A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeA;                       // 0x05A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeB;                       // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeA;                      // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeB;                      // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B4[0xC];                                      // 0x05B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Smackie">();
	}
	static class UFortAIFaunaAnimInstance_Smackie* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Smackie>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Smackie) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Smackie");
static_assert(sizeof(UFortAIFaunaAnimInstance_Smackie) == 0x0005C0, "Wrong size on UFortAIFaunaAnimInstance_Smackie");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, bIsIdleShuffleTurn) == 0x000580, "Member 'UFortAIFaunaAnimInstance_Smackie::bIsIdleShuffleTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShuffleBodyBend) == 0x000584, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShuffleBodyBend' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShufflePlayRate) == 0x000588, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShufflePlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, bIdleShuffleTurnDirection) == 0x00058C, "Member 'UFortAIFaunaAnimInstance_Smackie::bIdleShuffleTurnDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, bCanTransitionIdleToHop) == 0x00058D, "Member 'UFortAIFaunaAnimInstance_Smackie::bCanTransitionIdleToHop' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, bCanTransitionHopToIdle) == 0x00058E, "Member 'UFortAIFaunaAnimInstance_Smackie::bCanTransitionHopToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, bCanTransitionFallToIdle) == 0x00058F, "Member 'UFortAIFaunaAnimInstance_Smackie::bCanTransitionFallToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, bCanTransitionFallToHop) == 0x000590, "Member 'UFortAIFaunaAnimInstance_Smackie::bCanTransitionFallToHop' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, SpeedThreshold) == 0x000594, "Member 'UFortAIFaunaAnimInstance_Smackie::SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShuffleBodyBendMultiplier) == 0x000598, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShuffleBodyBendMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShuffleTurnThreshold) == 0x00059C, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShuffleTurnThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShuffleTurnDirectionThreshold) == 0x0005A0, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShuffleTurnDirectionThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShufflePlayRateInRangeA) == 0x0005A4, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShufflePlayRateInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShufflePlayRateInRangeB) == 0x0005A8, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShufflePlayRateInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShufflePlayRateOutRangeA) == 0x0005AC, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShufflePlayRateOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShufflePlayRateOutRangeB) == 0x0005B0, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShufflePlayRateOutRangeB' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaLayerAnimInstance
// 0x0000 (0x03F0 - 0x03F0)
class UFortAIFaunaLayerAnimInstance final : public UFortBaseLayerAnimInstance
{
public:
	class UAnimInstance*                          MainAnimBP;                                        // 0x03E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaLayerAnimInstance">();
	}
	static class UFortAIFaunaLayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaLayerAnimInstance>();
	}
};
static_assert(alignof(UFortAIFaunaLayerAnimInstance) == 0x000010, "Wrong alignment on UFortAIFaunaLayerAnimInstance");
static_assert(sizeof(UFortAIFaunaLayerAnimInstance) == 0x0003F0, "Wrong size on UFortAIFaunaLayerAnimInstance");
static_assert(offsetof(UFortAIFaunaLayerAnimInstance, MainAnimBP) == 0x0003E8, "Member 'UFortAIFaunaLayerAnimInstance::MainAnimBP' has a wrong offset!");

}

